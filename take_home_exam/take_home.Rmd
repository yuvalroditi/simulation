---
title: '311306435'
output: pdf_document
date: '2023-07-18'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

```{}
install.packages("DirichletReg")
install.packages("scatterplot3d") # Install
install.packages("MASS")
install.packages("MCMCprecision")


require(MCMCprecision)
library(Formula)
library(DirichletReg)
library("scatterplot3d") # load
library(MASS)


# beta_func <- function(alphas){
#   alphas_gamma_sum <- gamma(sum(alphas))
#   alphas_gamma_mul <-1
#   for (i in 1:length(alphas)){
#     alphas_gamma_mul <- alphas_gamma_mul * gamma(alphas[i])
#   }
#   return(alphas_gamma_mul/alphas_gamma_sum)
# }

# obs_amount <- dim(observations)[1]
  # alphas <- t(replicate(obs_amount, prior_sampler(rates)))
  # likelihood <- ddirichlet(observations, alphas)
  # priors <- dexp(alphas)
  # posterior <- numeric(length=obs_amount)
  # for (i in (1:obs_amount))
  #   posterior[i] <- prod(alphas[i]) * prod(likelihood[i])
  # df <- data.frame(
  #   x = c(alphas[,1]),
  #   y = c(alphas[,2]),
  #   z = c(posterior)
  # )
  # maximal <-df[which.max(df$z),3]
  # return(df)

```


Question 1

```{r pressure, echo=FALSE}


# auxiliary functions
log.lik.dir <- function(X, alpha, delta){
  l <- DirichletReg::ddirichlet(X, alpha, log = TRUE)
  return(sum(l) - sum(alpha*delta) + sum(log(delta)))
}

grad.log.lik.dir <- function(X, alpha, delta){
  term1 <- colSums(log(X))
  term2 <- nrow(X)*(digamma(sum(alpha))-digamma(alpha))
  return(term1 + term2 - delta)
}

hess.log.lik.dir <- function(X, alpha, delta){
  term1 <- trigamma(sum(alpha))*matrix(1,length(alpha),length(alpha))
  term2 <- diag(trigamma(alpha))
  return(nrow(X)*(term1 - term2))
}

max.log.lik.dir <- function(X, delta, precision = 0.001, max.iter = 100){
  al <- fit_dirichlet(X)$alpha # Initiate
  iter <- d <- 1
  while ((d > precision) & (iter <= max.iter)){
    l <- log.lik.dir(X, al, delta)
    W <- solve(hess.log.lik.dir(X, al, delta))
    v <- grad.log.lik.dir(X, al, delta)
    al <- as.vector(al - W %*% v)
    d <- abs(log.lik.dir(X, al, delta)-l)
    iter <- iter + 1
  }
  if(iter >= max.iter) warning("Stopped before convergence")
  return(list(alpha.hat = al,
              log.lik.hat = log.lik.dir(X, al, delta),
              gradient = v,
              hessian = hess.log.lik.dir(X, al, delta),
              number.iter = iter,
              log.lik.dif = d))
}

# Producing the Gaussian approximation
sim.dir <- function(n, alpha_prior, obs){
  #delta <- 1/alpha_prior
  delta <- alpha_prior
  out <- max.log.lik.dir(obs, delta)
  print(out)
  mu <- out$alpha.hat
  print(-solve(out$hessian))
  Sigma <- -solve(out$hessian)
  A <- MASS::mvrnorm(n, mu, Sigma)
  return(A)
}


prior_sampler <-function(rates){
  k <- length(rates)
  prior_vec <- rexp(k, rates)
  return(prior_vec)
}

objective <- function(observations, rates, alphas){
  log_likelihood <- sum(ddirichlet(observations, alphas, log = TRUE))
  log_priors <- sum(dexp(rates, log = TRUE))
  log_posterior <- log_likelihood + log_priors
  return (log_posterior)
}
  
hessian <- function(alphas, n){
  k <- length(alphas)
  h <- (-n)*(diag(trigamma(alphas)) + matrix(-trigamma(sum(alphas)), 
                                                   nrow = k, ncol = k))
  return (h)
}

grad <- function(observation, rates, alphas){
  n <- dim(observation)[1]
  log_xj <- colSums(log(observation))
  log_rates <- log(rates)
  return(log_xj - log_rates -n * (digamma(alphas)-digamma(sum(alphas))))
}

opt <- function(observations, rates, tol = 0.001, max_iter = 1000){
  alpha_t <- fit_dirichlet(observations)$alpha
  f_prev <- objective(observations, rates, alpha_t) 
  diff <- Inf
  for(i in 1:max_iter){
    if (diff > tol){
      print(i)
      n <- dim(observations)[1]
      H <- solve(hessian(alpha_t, n))
      g <- grad(observations, rates, alpha_t)
      alpha_t <- as.vector(alpha_t - H %*% g) 
      f_new <- objective(observations, rates, alpha_t)
      diff <- abs(f_new - f_prev)
      f_prev <- f_new
    } else {
      return (alpha_t)
    }
  }
}

normal_est <- function(observations, rates){
  alphas <- opt(observations, rates)
  mean <- alphas
  n <- dim(observations)[1]
  h <- hessian(alphas, n)
  cov_mat <- ginv(-h)
  return(list(mean, cov_mat))
}


q1 <-function(n, observations, rates){
  estimators <- normal_est(observations, rates)
  mean <- unlist(estimators[1])
  print(mean)
  k <- length(mean)
  cov_mat <- matrix(unlist(estimators[2]), ncol = k, nrow=k)
  print(cov_mat)
  samples <- mvrnorm(n, mean, cov_mat)
  return (samples)
}
mat <- as.matrix(read.table("Q3.txt.Q", sep=" "))
# mat <- matrix(c(0.2,0.3,0.2,0.1,0.2,0.3,0.4,0.4,0.1,0.1,0.1,0.8), nrow=4, ncol=3)
print(q1(20, mat, c(0.1,0.2,0.15)))


print(sim.dir(20, c(0.1,0.2,0.15), mat))
#scatterplot3d(df$x, df$y, df$z)
```

